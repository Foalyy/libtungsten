#ifndef _GPIO_H_
#define _GPIO_H_

#include <stdint.h>
#include "error.h"

// General Purpose Input Output
// This module controls the chip input/output signal pins
namespace GPIO {

    // Peripheral memory space base address
    const uint32_t GPIO_BASE = 0x400E1000;
    const uint32_t PORT_REG_SIZE = 0x0200;

    // GPIO base type
    typedef struct {
        volatile uint32_t RW;
        volatile uint32_t SET;
        volatile uint32_t CLEAR;
        volatile uint32_t TOGGLE;
    } RSCT_REG;

    // Registers addresses
    const uint32_t OFFSET_GPER =      0x000;
    const uint32_t OFFSET_PMR0 =      0x010;
    const uint32_t OFFSET_PMR1 =      0x020;
    const uint32_t OFFSET_PMR2 =      0x030;
    const uint32_t OFFSET_ODER =      0x040;
    const uint32_t OFFSET_OVR =       0x050;
    const uint32_t OFFSET_PVR =       0x060;
    const uint32_t OFFSET_PUER =      0x070;
    const uint32_t OFFSET_PDER =      0x080;
    const uint32_t OFFSET_IER =       0x090;
    const uint32_t OFFSET_IMR0 =      0x0A0;
    const uint32_t OFFSET_IMR1 =      0x0B0;
    const uint32_t OFFSET_GFER =      0x0C0;
    const uint32_t OFFSET_IFR =       0x0D0;
    const uint32_t OFFSET_ODCR0 =     0x100;
    const uint32_t OFFSET_ODCR1 =     0x110;
    const uint32_t OFFSET_OSRR0 =     0x130;
    const uint32_t OFFSET_STER =      0x160;
    const uint32_t OFFSET_EVER =      0x180;
    const uint32_t OFFSET_PARAMETER = 0x1F8;
    const uint32_t OFFSET_VERSION =   0x1FC;

    // Pins are divided in 3 ports : A, B and C
    // 48-pin packages only have port A, 64-pin packages have ports A and B,
    // and 100-pin packages have all A, B and C ports 
    const int N_PORTS = 3;
    enum class Port {A, B, C};

    // Each pin can either be controlled as a generic input/output (GPIO mode)
    // are be dedicated to one of up to 8 peripheral functions
    // See datasheet 3.2 Peripheral Multiplexing on I/O Lines for more details
    enum class Periph {A, B, C, D, E, F, G, H};    

    // Each pin has an optional pulling resistor, either pull-up or pull-down.
    // Buskeeper is a special mode where the pin keeps the last signal (high or low)
    // applied to it, even when this signal is disconnected.
    enum class Pulling {
        NONE,
        PULLUP,
        PULLDOWN,
        BUSKEEPER
    };
    
    // An interrupt can be generated by each pin on one of these signal change
    enum class Trigger {
        CHANGE,
        RISING,
        FALLING
    };


    // This is the main struct used to define a pin, this should be used in user space, e.g.
    // GPIO::Pin pinLed = {GPIO::Port::A, 2};
    // (function is unused for pins in basic GPIO mode and can be ommited)
    struct Pin {
        Port port;
        uint8_t number;
        Periph function;
    };

    // The PinState type can be used for clearer types, even though it's basically a boolean
    using PinState = bool;
    const PinState HIGH = true;
    const PinState LOW = false;

    // Interrupts handling
    const uint8_t N_GPIO_LINES = 96; // Max on the 100-pin package
    const uint8_t N_INTERRUPT_CHANNELS = N_GPIO_LINES / 8; // Each interrupt channel covers 8 GPIO lines
    const uint8_t INTERRUPT_PRIORITY = 50;
    extern uint32_t portsState[]; // Used for rising(), falling() and changed()
    extern uint32_t interruptHandlers[];

    // Error codes
    const Error::Code ERR_PIN_ALREADY_IN_USE = 1;
    const Error::Code ERR_HANDLER_NOT_DEFINED = 2;


    // Module API

    // Basic GPIO functions
    void enableInput(const Pin& pin, Pulling pulling=Pulling::NONE);
    void enableOutput(const Pin& pin, PinState value);
    void setPulling(const Pin& pin, Pulling pulling);
    PinState get(const Pin& pin);
    void set(const Pin& pin, PinState value);

    // Pin peripheral functions
    // This is usually called by other library modules, not by the user
    void enablePeripheral(const Pin& pin);
    void disablePeripheral(const Pin& pin);

    // Interrupts
    void enableInterrupt(const Pin& pin, void (*handler)(), Trigger trigger=Trigger::RISING);
    void enableInterrupt(const Pin& pin, Trigger trigger=Trigger::RISING);
    void disableInterrupt(const Pin& pin);

    // Helper functions
    inline bool isHigh(const Pin& pin) { return get(pin) == HIGH; };
    inline bool isLow(const Pin& pin) { return get(pin) == LOW; };
    inline void setHigh(const Pin& pin) { set(pin, HIGH); };
    inline void setLow(const Pin& pin) { set(pin, LOW); };
    void blip(const Pin& pin);

    // These functions monitor the pins state by polling and are a simple
    // way to check for a signal change, e.g. checking for a button press
    bool risingEdge(const Pin& pin);
    bool fallingEdge(const Pin& pin);
    bool changed(const Pin& pin);

    // PA00 and PB00 can be turned on and off quickly with these functions.
    // This is useful for debug purposes, when you want to switch a pin when something
    // has happened but you want to use as few clock cycles as possible
    inline void enablePA00() {enableOutput({GPIO::Port::A, 0}, GPIO::LOW);}
    inline void setHighPA00() {((volatile RSCT_REG*)(GPIO_BASE + OFFSET_OVR))->SET = 1;}
    inline void setLowPA00() {((volatile RSCT_REG*)(GPIO_BASE + OFFSET_OVR))->CLEAR = 1;}
    inline void enablePB00() {enableOutput({GPIO::Port::B, 0}, GPIO::LOW);}
    inline void setHighPB00() {((volatile RSCT_REG*)(GPIO_BASE + PORT_REG_SIZE + OFFSET_OVR))->SET = 1;}
    inline void setLowPB00() {((volatile RSCT_REG*)(GPIO_BASE + PORT_REG_SIZE + OFFSET_OVR))->CLEAR = 1;}

    // Internal initialization function. This is called in Core::init() and don't have to
    // be called by the user.
    void init();

}


#endif